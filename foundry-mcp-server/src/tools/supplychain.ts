import { exec } from 'child_process';
import { promisify } from 'util';
import { readFileSync, writeFileSync } from 'fs';
import { join, resolve } from 'path';
import { MCPToolResult, SupplyChainDeployParams } from '../types/foundry.js';
import { ForgeManagement } from './forge.js';
import { CastOperations } from './cast.js';

const execAsync = promisify(exec);

/**
 * Supply Chain specific operations
 * High-level helpers for the SupplyChain project
 */
export class SupplyChainHelpers {
  private forgeManagement: ForgeManagement;
  private castOperations: CastOperations;

  constructor() {
    this.forgeManagement = new ForgeManagement();
    this.castOperations = new CastOperations();
  }

  /**
   * Deploy SupplyChain contract and optionally update config.ts
   */
  async deploySupplyChain(params: SupplyChainDeployParams = {}): Promise<MCPToolResult> {
    try {
      const { rpcUrl = 'http://127.0.0.1:8545', privateKey, updateConfig = true } = params;

      // First compile
      console.error('üî® Compilando contratos...');
      const compileResult = await this.forgeManagement.compileContracts({
        optimize: true,
        optimizerRuns: 200,
        workingDir: './sc'
      });

      if (compileResult.isError) {
        return compileResult;
      }

      // Then deploy
      console.error('üöÄ Desplegando SupplyChain...');
      const deployResult = await this.forgeManagement.deployContract({
        contractName: 'SupplyChain',
        privateKey,
        rpcUrl,
        workingDir: './sc'
      });

      if (deployResult.isError) {
        return deployResult;
      }

      // Extract deployed address
      const addressMatch = deployResult.content[0].text.match(/üìç Direcci√≥n: (0x[a-fA-F0-9]{40})/);
      const deployedAddress = addressMatch ? addressMatch[1] : null;

      if (!deployedAddress) {
        return {
          content: [{
            type: 'text',
            text: '‚ùå No se pudo obtener la direcci√≥n del contrato desplegado'
          }],
          isError: true
        };
      }

      // Update config.ts if requested
      if (updateConfig) {
        try {
          const configPath = resolve('./web/src/contracts/config.ts');
          const abiPath = resolve('./sc/out/SupplyChain.sol/SupplyChain.json');
          
          const artifact = JSON.parse(readFileSync(abiPath, 'utf-8'));
          const abi = artifact.abi;

          const configContent = `// Auto-generated by MCP Foundry Server
// Contract deployed at: ${new Date().toISOString()}

export const CONTRACT_CONFIG = {
  address: '${deployedAddress}',
  abi: ${JSON.stringify(abi, null, 2)}
} as const;
`;

          writeFileSync(configPath, configContent, 'utf-8');

          return {
            content: [{
              type: 'text',
              text: deployResult.content[0].text + '\n\n' +
                    `‚úÖ Configuraci√≥n actualizada\n` +
                    `üìÑ Archivo: web/src/contracts/config.ts\n` +
                    `üìç Nueva direcci√≥n: ${deployedAddress}\n\n` +
                    `üí° El frontend ahora apunta al nuevo contrato\n` +
                    `üí° Reinicia el servidor de desarrollo si est√° corriendo`
            }],
            isError: false
          };

        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : 'Error desconocido';
          return {
            content: [{
              type: 'text',
              text: deployResult.content[0].text + '\n\n' +
                    `‚ö†Ô∏è Advertencia: No se pudo actualizar config.ts: ${errorMessage}\n` +
                    `üí° Actualiza manualmente la direcci√≥n: ${deployedAddress}`
            }],
            isError: false
          };
        }
      }

      return deployResult;

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Error desconocido';
      return {
        content: [{
          type: 'text',
          text: `‚ùå Error en deploy de SupplyChain: ${errorMessage}`
        }],
        isError: true
      };
    }
  }

  /**
   * Run all SupplyChain tests
   */
  async testSupplyChain(): Promise<MCPToolResult> {
    return this.forgeManagement.runTests({
      verbosity: 2,
      gasReport: true,
      contractPattern: 'SupplyChain',
      workingDir: './sc'
    });
  }

  /**
   * Setup complete development environment
   */
  async setupDevEnvironment(privateKey?: string): Promise<MCPToolResult> {
    try {
      const steps = [];

      // Step 1: Compile contracts
      steps.push('üî® Compilando contratos...');
      const compileResult = await this.forgeManagement.compileContracts({
        optimize: true,
        workingDir: './sc'
      });

      if (compileResult.isError) {
        return compileResult;
      }

      // Step 2: Run tests
      steps.push('‚úÖ Compilaci√≥n exitosa\nüß™ Ejecutando tests...');
      const testResult = await this.forgeManagement.runTests({
        verbosity: 2,
        workingDir: './sc'
      });

      if (testResult.isError) {
        return {
          content: [{
            type: 'text',
            text: steps.join('\n') + '\n' + testResult.content[0].text
          }],
          isError: true
        };
      }

      // Step 3: Deploy
      steps.push('‚úÖ Tests pasaron\nüöÄ Desplegando SupplyChain...');
      const deployResult = await this.deploySupplyChain({
        privateKey,
        updateConfig: true
      });

      if (deployResult.isError) {
        return {
          content: [{
            type: 'text',
            text: steps.join('\n') + '\n' + deployResult.content[0].text
          }],
          isError: true
        };
      }

      return {
        content: [{
          type: 'text',
          text: `‚úÖ Entorno de desarrollo configurado\n\n` +
                steps.join('\n') + '\n\n' +
                deployResult.content[0].text + '\n\n' +
                `üéâ ¬°Todo listo para desarrollar!\n` +
                `üí° El contrato est√° desplegado y el frontend configurado\n` +
                `üí° Puedes empezar a probar la aplicaci√≥n`
        }],
        isError: false
      };

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Error desconocido';
      return {
        content: [{
          type: 'text',
          text: `‚ùå Error configurando entorno: ${errorMessage}`
        }],
        isError: true
      };
    }
  }
}
